<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Falaise: Writing FLReconstruct Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Falaise
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">SuperNEMO Software Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Writing FLReconstruct Modules </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introduction">Introduction to the writing of FLReconstruct modules </a></li>
<li class="level1"><a href="#minimalmodule">Implementing a Minimal flreconstruct Module </a><ul><li class="level2"><a href="#minimalmodule_sources">Creating the Module Sources </a></li>
<li class="level2"><a href="#minimalmodulebuilding">Building a Loadable Shared Library </a></li>
<li class="level2"><a href="#minimalmodulerunning">Running flreconstruct With a Custom Module </a></li>
</ul>
</li>
<li class="level1"><a href="#minimalconfigurablemodule">Making Your Module Configurable </a><ul><li class="level2"><a href="#minimalconfigurablemodulecpp">Adding a Configurable Data Member </a></li>
<li class="level2"><a href="#minimalconfigurablemodulescript">Configuring MyModule from the Pipeline Script </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction to the writing of FLReconstruct modules </h1>
<p>If you have just started using Falaise or the FLReconstruct application, we strongly recommend that you familiarize yourself with the basic usage of FLReconstruct covered in <a class="el" href="usingflreconstruct.html">The FLReconstruct Application</a>.</p>
<p>FLReconstruct uses a <a href="http://en.wikipedia.org/wiki/Pipeline_%28software%29">pipeline pattern</a> to process events. You can view this like a production line with each stage on the line performing some operation on the event. Each stage in the pipeline is called a "pipeline module" (or just "module") and is implemented as a C++ class. The FLReconstruct application can load new modules at runtime using a <a href="http://en.wikipedia.org/wiki/Plug-in_%28computing%29">"plugin" mechanism</a>. Scripting, as demonstrated in the <a class="el" href="usingflreconstruct.html">tutorial on using FLReconstruct</a>, is used to load new modules from plugins, select the modules to use in the pipeline, and configure each module.</p>
<p>In this tutorial we will see how to implement our own modules for use in the FLReconstruct pipeline. This will cover</p>
<ol type="1">
<li>Writing the basic C++ class for a pipeline class</li>
<li>Compiling the class into a plugin for use by FLReconstruct</li>
<li>Scripting the loading and use of the plugin in FLReconstruct</li>
<li>Implementing runtime module configuration</li>
</ol>
<p>Getting your module to actually do something with the events that are passed to it is deferred to <a class="el" href="workingwitheventrecords.html">a later tutorial</a>.</p>
<h1><a class="anchor" id="minimalmodule"></a>
Implementing a Minimal flreconstruct Module </h1>
<h2><a class="anchor" id="minimalmodule_sources"></a>
Creating the Module Sources </h2>
<p>We begin by creating an empty directory to hold the source code for our example module, which we'll name "MyModule"</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ cd MyWorkSpace</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ mkdir MyModule</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;$ cd MyModule</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ ls</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;$</div></div><!-- fragment --><p>You are free to organise the source code under this directory as you see fit. In this very simple case we will just place all files in the <code>MyModule</code> directory without any subdirectories.</p>
<p>A "pipeline module" (or just "module") in FLReconstruct is a C++ class inheriting from Bayeux's dpp::base_module abstract base class. This declares three pure abstract methods that any concrete module <b>must</b> implement:</p>
<ul>
<li>dpp::base_module::initialize</li>
<li>dpp::base_module::process</li>
<li>dpp::base_module::reset</li>
</ul>
<p>In addition, to make the module loadable by <code>flreconstruct</code>, we need to use a couple of macros to declare and define the loading and registration mechanisms for us.</p>
<p>We therefore begin implementing our module by writing the header file, which we'll name <code>MyModule.h</code>:</p>
<div class="fragment"><div class="line"><span class="comment">//! \file    MyModule.h</span></div><div class="line"><span class="comment"></span><span class="comment">//! \brief   Example processing module for flreconstruct</span></div><div class="line"><span class="comment"></span><span class="comment">//! \details Process a things object</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="preprocessor">#ifndef MYMODULE_HH</span></div><div class="line"><span class="preprocessor">#define MYMODULE_HH</span></div><div class="line"><span class="comment">// Standard Library</span></div><div class="line"></div><div class="line"><span class="comment">// Third Party</span></div><div class="line"><span class="comment">// - Bayeux</span></div><div class="line"><span class="preprocessor">#include &quot;bayeux/dpp/base_module.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// This Project</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyModule : <span class="keyword">public</span> dpp::base_module {</div><div class="line"> <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //! Construct module</span></div><div class="line"><span class="comment"></span>  MyModule();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Destructor</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> ~MyModule();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Configure the module</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">initialize</a>(<span class="keyword">const</span> datatools::properties&amp; myConfig,</div><div class="line">                          datatools::service_manager&amp; flServices,</div><div class="line">                          dpp::module_handle_dict_type&amp; moduleDict);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Process supplied data record</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> dpp::base_module::process_status process(datatools::things&amp; workItem);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Reset the module</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Macro which automatically creates the interface needed</span></div><div class="line">  <span class="comment">// to enable the module to be loaded at runtime</span></div><div class="line">  DPP_MODULE_REGISTRATION_INTERFACE(MyModule);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // MYMODULE_HH</span></div></div><!-- fragment --><p>Note the inheritance from dpp::base_module, declaration of the three virtual methods and use of the macro DPP_MODULE_REGISTRATION_INTERFACE. Note also the use of Doxygen markup to document the file and methods. You don't need to do this, but it is very useful and helps if your module is to be integrated into the official mainline pipeline.</p>
<p>With the header in place, we now add the implementation file, which we'll name <code>MyModule.cpp</code></p>
<div class="fragment"><div class="line"><span class="comment">// - Implementation of MyModule</span></div><div class="line"></div><div class="line"><span class="comment">// Ourselves</span></div><div class="line"><span class="preprocessor">#include &quot;MyModule.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Standard Library</span></div><div class="line"></div><div class="line"><span class="comment">// Third Party</span></div><div class="line"><span class="comment">// - A</span></div><div class="line"></div><div class="line"><span class="comment">// This Project</span></div><div class="line"></div><div class="line"><span class="comment">// Macro which automatically implements the interface needed</span></div><div class="line"><span class="comment">// to enable the module to be loaded at runtime</span></div><div class="line"><span class="comment">// The first argument is the typename</span></div><div class="line"><span class="comment">// The second is the string key used to access the module in pipeline</span></div><div class="line"><span class="comment">// scripts. This must be globally unique.</span></div><div class="line">DPP_MODULE_REGISTRATION_IMPLEMENT(MyModule,<span class="stringliteral">&quot;MyModule&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Construct</span></div><div class="line">MyModule::MyModule() : dpp::base_module()</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="comment">// Destruct</span></div><div class="line">MyModule::~MyModule() {</div><div class="line">  <span class="comment">// MUST reset module at destruction</span></div><div class="line">  this-&gt;reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Initialize</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">MyModule::initialize</a>(<span class="keyword">const</span> datatools::properties&amp; <span class="comment">/*myConfig*/</span>,</div><div class="line">                          datatools::service_manager&amp; <span class="comment">/*flServices*/</span>,</div><div class="line">                          dpp::module_handle_dict_type&amp; <span class="comment">/*moduleDict*/</span>) {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Process</span></div><div class="line">dpp::base_module::process_status</div><div class="line">MyModule::process(datatools::things&amp; <span class="comment">/*workItem*/</span>) {</div><div class="line">  <span class="comment">// Hello world!</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;MyModule::process called!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// MUST return a status, see ref dpp::base_module::process_status</span></div><div class="line">  <span class="keywordflow">return</span> PROCESS_OK;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Reset</span></div><div class="line"><span class="keywordtype">void</span> MyModule::reset() {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p>Here we've implemented the trivial constructor/destructor and the three virtual methods, and added the DPP_MODULE_REGISTRATION_IMPLEMENT macro. This macro, together with the use of DPP_MODULE_REGISTRATION_INTERFACE in the header file provide all the boilerplate needed to allow <code>MyModule</code> to be loaded by <code>flreconstruct</code>. Note especially that DPP_MODULE_REGISTRATION_IMPLEMENT takes two arguments; the actual typename and a string key, the latter being used to identify the module in pipeline scripts. In principle the key can be anything you like, but for clarity and uniqueness we strongly recommend it match the class name.</p>
<p>The initialize method is used to configure the module. At present <code>MyModule</code> does not require any configuration, so all we do is call the base class _set_initialized to mark it as initialized. This marking is required by the pipeline management system, so you should always call this method at the end of your module's initialize method.</p>
<p>The process method performs the actual operation on the event, which is represented as a datatools::things class, and passed to the method as a datatools::things reference. As noted above, a later tutorial will cover the interface and use of datatools::things . We therefore don't do anything with the event, and simply write a message to standard output so that we'll be able to see the method being called in <code>flreconstruct</code>. The process method <b>must</b> return a processing exit code. In this case, our processing is always successful, so we return dpp::base_module::PROCESS_OK.</p>
<p>The reset method is used to reset any configuration performed by the initialize method. In this example, there is no configuration, so all we do is is call the base class _set_initialized to mark it as reset. This marking is required by the pipeline management system, so you should always call this method at the end of your module's reset method. Note especially the call to <code>reset</code> in the destructor, as the pipeline management system requires modules to be uninitialized at destruction.</p>
<h2><a class="anchor" id="minimalmodulebuilding"></a>
Building a Loadable Shared Library </h2>
<p>With the source code for <code>MyModule</code> in place we need to build a shared library from it that <code>flreconstruct</code> can load at runtime to make <code>MyModule</code> available for use in the pipeline. As <code>MyModule</code> uses components from Bayeux, the compilation needs to have the path to the Bayeux headers available. The simplest way to do this is to use CMake to build the shared library and make use of Bayeux's <a href="http://www.cmake.org/cmake/help/v2.8.10/cmake.html#command:find_package">find_package</a> support.</p>
<p>To do this, we add a CMake script alongside the sources:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ ls</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;MyModule.h  MyModule.cpp</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;$ touch CMakeLists.txt</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ ls</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;CMakeLists.txt MyModule.h MyModule.cpp</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;$</div></div><!-- fragment --><p>The implementation of <code>CMakeLists.txt</code> is very straightforward:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># - Basic CMake setup</span></div><div class="line"><span class="preprocessor"># Check version meets ou requirements</span></div><div class="line"><span class="preprocessor"># Declare project, which will configure compiler for us</span></div><div class="line">cmake_minimum_required(VERSION 2.8)</div><div class="line">project(MyModule)</div><div class="line"></div><div class="line"><span class="preprocessor"># Modules use Bayeux, so we need to locate this or fail</span></div><div class="line">find_package(Bayeux REQUIRED)</div><div class="line"></div><div class="line"><span class="preprocessor"># Ensure our code can see the Bayeux headers</span></div><div class="line">include_directories(${Bayeux_INCLUDE_DIRS})</div><div class="line"></div><div class="line"># Build a dynamic library from our sources</div><div class="line">add_library(MyModule SHARED MyModule.h MyModule.cpp)</div><div class="line"></div><div class="line"><span class="preprocessor"># Apple linker requires dynamic lookup of symbols, so we</span></div><div class="line"><span class="preprocessor"># add link flags on this platform</span></div><div class="line"><span class="keywordflow">if</span>(APPLE)</div><div class="line">  set_target_properties(MyModule</div><div class="line">    PROPERTIES LINK_FLAGS <span class="stringliteral">&quot;-undefined dynamic_lookup&quot;</span></div><div class="line">    )</div><div class="line">endif()</div></div><!-- fragment --><p>Comments begin with a <code>#</code>. The first two commands simply setup CMake and the compiler for us. The <code>find_package</code> command will locate Bayeux for us, with the <code>REQUIRED</code> argument ensuring CMake will fail it Bayeux cannot be found for any reason. The <code>include_directories</code> command uses a variable set by the preceeding <code>find_package</code> command to ensure the compiler can locate Bayeux's headers. Finally, the <code>add_library</code> and <code>set_target_properties</code> commands are used to build and link actual library. Breaking the arguments to <code>add_library</code> down one by one:</p>
<ol type="1">
<li><code>MyModule</code> : the name of the library, which will be used to create the on disk name. For example, on Linux, this will output a library file <code>libMyModule.so</code>, and on Mac OS X a library file <code>libMyModule.dylib</code>.</li>
<li><code>SHARED</code> : the type of the library, in this case a dynamic library.</li>
<li><code>MyModule.h MyModule.cpp</code> : all the sources need to build the library. The header is also listed so that it will show up in IDEs like Xcode.</li>
</ol>
<p>The use of <code>set_target_properties</code> is restricted to Apple platforms, and adds flags to pass to the linker when linking the <code>MyModule</code> library. This is needed because the Apple dynamic linker requires all symbols (the functions/classes in/used by the binary library) to be found at link time. The <code>MyModule</code> class uses symbols from the Bayeux library, so strictly speaking we should link <code>libMyModule</code> to <code>libBayeux</code>. However, as we will load <code>libMyModule</code> into <code>flreconstruct</code>, we can rely on the latter to provide these symbols for us (so called dynamic lookup). The extra link flags therefore tell the Apple linker to use this runtime lookup mechanism.</p>
<p>For more detailed documentation on CMake, please refer to the <a href="http://www.cmake.org/cmake/help/documentation.html">online help</a>.</p>
<p>To build the library, we first create a so-called <em>build directory</em> so that we can isolate the binary files from the source code. This can be wherever you like, but it's usually most convenient to create this alongside the directory in which the sources reside. In this example we have the directory structure:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ pwd</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/path/to/MyWorkSpace</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;$ tree .</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;`-- MyModule</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    |-- CMakeLists.txt</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    |-- MyModule.cpp</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    `-- MyModule.h</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;1 directory, 3 files</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;$</div></div><!-- fragment --><p>so we can create the build directory under <code>/path/to/MyWorkSpace</code> as</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ mkdir MyModule-build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ tree .</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;|-- MyModule</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;|   |-- CMakeLists.txt</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;|   |-- MyModule.cpp</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;|   `-- MyModule.h</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;`-- MyModule-build</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;2 directories, 3 files</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;$</div></div><!-- fragment --><p>The first step of the build is to change into the build directory and run <code>cmake</code> to configure the build of <code>MyModule</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ cd MyModule-build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ cmake -DBayeux_DIR=/where/BayeuxConfig/is ../MyModule</div></div><!-- fragment --><p>Here, the <code>Bayeux_DIR</code> argument should be the directory which holds the file <code>BayeuxConfig.cmake</code>. This file is installed by Bayeux, and will be located in the directory <code>&lt;prefix&gt;/lib/cmake/Bayeux-&lt;bxversion&gt;</code>, where <code>&lt;prefix&gt;</code> is the root directory of your Falaise/Bayeux installation and &lt;bxversion&gt; is the current Bayeux version. The argument <code>../MyModule</code> points CMake to the directory holding the <code>CMakeLists.txt</code> file for the project we want to build, in this case our custom module.</p>
<p>Running the command will produce output that is highly system dependent, but you should see something along the lines of</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ cmake -DBayeux_DIR=/where/BayeuxConfig/is ../MyModule</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;-- The C compiler identification is GNU 4.3.4</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;-- The CXX compiler identification is GNU 4.3.4</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;-- Check for working C compiler: /usr/bin/cc</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;-- Check for working C compiler: /usr/bin/cc -- works</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;-- Detecting C compiler ABI info</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;-- Detecting C compiler ABI info - done</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;-- Check for working CXX compiler: /usr/bin/c++</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;-- Check for working CXX compiler: /usr/bin/c++ -- works</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;-- Detecting CXX compiler ABI info</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;-- Detecting CXX compiler ABI info - done</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;-- Configuring done</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;-- Generating done</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;-- Build files have been written to: /path/to/MyWorkSpace/MyModule-build</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;$</div></div><!-- fragment --><p>The last three lines are common (apart from the path), and indicate a successful configuration. Listing the contents of the directory shows that CMake has generated a Makefile for us:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ ls</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;$</div></div><!-- fragment --><p>To build the library for our module we therefore simply run make:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ make</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Scanning dependencies of target MyModule</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;[100%] Building CXX object CMakeFiles/MyModule.dir/MyModule.cpp.o</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Linking CXX shared library libMyModule.so</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;[100%] Built target MyModule</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;$</div></div><!-- fragment --><p>If the build succeeds, we now have the shared library present in our build directory:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ ls</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;CMakeCache.txt  CMakeFiles  cmake_install.cmake  libMyModule.so  Makefile</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;$</div></div><!-- fragment --><p>With the library built, we now need to make <code>flreconstruct</code> aware of it and to use it in the pipeline.</p>
<h2><a class="anchor" id="minimalmodulerunning"></a>
Running flreconstruct With a Custom Module </h2>
<p>To use our new module in <code>flreconstruct</code> we need to tell the application about it and then use it in the pipeline. We do this via the pipeline script we pass to <code>flreconstruct</code> via</p>
<ol type="1">
<li>Adding a new section named <code>flreconstruct.plugins</code> which tells the application about libraries to be loaded.</li>
<li>Declaring a section for our module/</li>
</ol>
<p>We create a script named <code>MyModulePipeline.conf</code> in our project directory:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ pwd</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/path/to/MyWorkSpace/MyModule</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;$ ls</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;CMakeLists.txt  MyModule.cpp  MyModule.h  MyModulePipeline.conf</div></div><!-- fragment --><p>This script takes the same basic form as shown in the <a class="el" href="usingflreconstruct.html">tutorial on using flreconstruct</a>:</p>
<div class="fragment"><div class="line"># - Configuration Metadata</div><div class="line">#@description Chain pipeline using a single custom module</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line"># The &quot;flreconstruct.plugins&quot; section to tell flreconstruct what</div><div class="line"># to load and from where.</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line"># Make it use our custom module by setting the&#39;type&#39; key to the string we</div><div class="line"># used as the second argument to the macro</div><div class="line"># DPP_MODULE_REGISTRATION_IMPLEMENT in MyModule.cpp</div><div class="line"># At present, it takes no configuration, so it suffices to define it</div><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>The <code>plugins</code> key in the <code>flreconstruct.plugins</code> section is a list of strings naming the libraries to be loaded by <code>flreconstruct</code> at startup. If these libraries contain modules, they will be automatically loaded. By default, the string(s) you provide will be used as the library name, and it will be searched for as a file named <code>libNAME.{so,dylib}</code> under</p>
<ol type="1">
<li>The current working directory,</li>
<li>The paths in <code>{DY}LD_LIBRARY_PATH</code>,</li>
<li>The system paths known to the dynamic linker.</li>
</ol>
<p>Note that as of Mac OSX El Capitan, <code>DYLD_LIBRARY_PATH</code> is ignored and cannot be used to set module lookup paths. You can also explicitly specify the directory to look in for the library to override the default lookup paths. For example, we built the <code>MyModule</code> library in <code>/path/to/MyWorkSpace/MyModule-build</code>, so we can force <code>flreconstruct</code> to look there, and only there, by doing</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;plugins : string[1] = &quot;MyModule&quot;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;MyModule.directory : string = &quot;/path/to/MyWorkSpace/MyModule-build&quot;</div></div><!-- fragment --><p>With the loading of the custom module in place, we can use it in the script as we did for the builtin modules. As we did in in the <a class="el" href="writingflreconstructpipelinescripts.html#trivial_pipeline">trivial pipeline example for flreconstruct</a>, we can simply declare the main pipeline module as being of the <code>MyModule</code> type, hence the line</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div></div><!-- fragment --><p>Note that the <code>type</code> key value must always refer to the id with which the module was registered, and this is determined by the second argument to the DPP_MODULE_REGISTRATION_IMPLEMENT macro called in the source code for the module. Remember that when we wrote <code>MyModule.cpp</code> we called the macro as:</p>
<div class="fragment"><div class="line">DPP_MODULE_REGISTRATION_IMPLEMENT(MyModule,<span class="stringliteral">&quot;MyModule&quot;</span>);</div></div><!-- fragment --><p>This is why we recommend that you register your modules with an id equal to their C++ typename. It makes it absolutely clear which module is to be constructed and minimizes potential name clashes.</p>
<p>We can now run <code>flreconstruct</code> with <code>MyModulePipeline.conf</code> as the pipeline script. Because we're relying on the default lookup of the <code>MyModule</code> library, we first change to the directory in which this library resides, namely our build directory. We also need to have a file to process, so we run <code>flsimulate</code> first to create a simple file of one event (NB in the following, we assume you have <code>flsimulate</code> and <code>flreconstruct</code> in your <code>PATH</code>).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ cd /path/to/MyWorkSpace/MyModule-build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ ls</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;CMakeCache.txt  CMakeFiles  cmake_install.cmake  libMyModule.so  Makefile</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ flsimulate -n1 -o MyModuleTest.brio</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;....</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;$ ls</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;CMakeCache.txt  cmake_install.cmake  Makefile</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;CMakeFiles      libMyModule.so       MyModuleTest.brio</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModulePipeline.conf</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;[notice:void datatools::library_loader::init():410] Automatic loading of library  &#39;MyModule&#39;...</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;...</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Reader configuration parameters:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;|-- Name : &quot;files.mode&quot;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;|   |-- Type  : string (scalar)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;|   `-- Value : &quot;single&quot;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;`-- Name : &quot;files.single.filename&quot;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    |-- Type  : string (scalar)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    `-- Value : &quot;MyModuleTest.brio&quot;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;MyModule::process called!</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;$</div></div><!-- fragment --><p>So we can see that <code>flreconstruct</code> loaded the <code>MyModule</code> library for us, and the <code>MyModule::process</code> method was called, showing that the pipeline used our custom module! We can also add our module into a chain pipeline and other pipeline structures. For example, try the following pipeline script:</p>
<div class="fragment"><div class="line"># - Configuration</div><div class="line">#@description Simple pipeline using a chain</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Module load section</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line"></div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line">[name=&quot;pipeline&quot; type=&quot;dpp::chain_module&quot;]</div><div class="line">modules : string[3] = &quot;start_module&quot; &quot;dump&quot; &quot;end_module&quot;</div><div class="line"></div><div class="line">[name=&quot;start_module&quot; type=&quot;MyModule&quot;]</div><div class="line"></div><div class="line">[name=&quot;dump&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line"></div><div class="line">[name=&quot;end_module&quot; type=&quot;MyModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>You should see each event being dumped, with the dumped info being bracketed by the <code>MyModule::process called!</code> text from each of the <code>MyModule</code> instances in the chain.</p>
<h1><a class="anchor" id="minimalconfigurablemodule"></a>
Making Your Module Configurable </h1>
<p>The minimal module presented in <a class="el" href="writingflreconstructmodules.html#minimalmodule">the section above</a> outputs a fixed message which can only be changed by modifiying the code and recompiling the module. In most use cases hard-coding like this is sufficient, but if your module has parameters that may change frequently (e.g. a threshold that requires optimization), it is easy to make them configurable at runtime through the pipeline script. To demonstrate this, we'll modify the <code>MyModule</code> class from earlier to have a single <code>double</code> type data member and make this configurable.</p>
<h2><a class="anchor" id="minimalconfigurablemodulecpp"></a>
Adding a Configurable Data Member </h2>
<p>To begin with we simply add the declaration of the data member in the header file:</p>
<div class="fragment"><div class="line"><span class="comment">//! \file    MyModule.h</span></div><div class="line"><span class="comment"></span><span class="comment">//! \brief   Example processing module for flreconstruct</span></div><div class="line"><span class="comment"></span><span class="comment">//! \details Process a things object</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="preprocessor">#ifndef MYMODULE_HH</span></div><div class="line"><span class="preprocessor">#define MYMODULE_HH</span></div><div class="line"><span class="comment">// Standard Library</span></div><div class="line"></div><div class="line"><span class="comment">// Third Party</span></div><div class="line"><span class="comment">// - Bayeux</span></div><div class="line"><span class="preprocessor">#include &quot;bayeux/dpp/base_module.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// This Project</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyModule : <span class="keyword">public</span> dpp::base_module {</div><div class="line"> <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //! Construct module</span></div><div class="line"><span class="comment"></span>  MyModule();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Destructor</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> ~MyModule();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Configure the module</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">initialize</a>(<span class="keyword">const</span> datatools::properties&amp; myConfig,</div><div class="line">                          datatools::service_manager&amp; flServices,</div><div class="line">                          dpp::module_handle_dict_type&amp; what);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Process supplied data record</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> dpp::base_module::process_status process(datatools::things&amp; workItem);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Reset the module</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //! A configurable value</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> fudgeFactor_;</div><div class="line"></div><div class="line">  <span class="comment">// Macro which automatically creates the interface needed</span></div><div class="line">  <span class="comment">// to enable the module to be loaded at runtime</span></div><div class="line">  DPP_MODULE_REGISTRATION_INTERFACE(MyModule);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // MYMODULE_HH</span></div></div><!-- fragment --><p>and add extra code in the implementation file to handle the management of the member:</p>
<div class="fragment"><div class="line"><span class="comment">// - Implementation of MyModule</span></div><div class="line"></div><div class="line"><span class="comment">// Ourselves</span></div><div class="line"><span class="preprocessor">#include &quot;MyModule.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Standard Library</span></div><div class="line"></div><div class="line"><span class="comment">// Third Party</span></div><div class="line"><span class="comment">// - A</span></div><div class="line"></div><div class="line"><span class="comment">// This Project</span></div><div class="line"></div><div class="line"><span class="comment">// Macro which automatically implements the interface needed</span></div><div class="line"><span class="comment">// to enable the module to be loaded at runtime</span></div><div class="line"><span class="comment">// The first argument is the typename</span></div><div class="line"><span class="comment">// The second is the string key used to access the module in pipeline</span></div><div class="line"><span class="comment">// scripts. This must be globally unique.</span></div><div class="line">DPP_MODULE_REGISTRATION_IMPLEMENT(MyModule,<span class="stringliteral">&quot;MyModule&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Construct</span></div><div class="line">MyModule::MyModule() : dpp::base_module(), fudgeFactor_(1.0) {</div><div class="line">  this-&gt;reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Destruct</span></div><div class="line">MyModule::~MyModule() {</div><div class="line">  <span class="comment">// MUST reset module at destruction</span></div><div class="line">  <span class="keywordflow">if</span> (this-&gt;is_initialized()) this-&gt;reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Initialize</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">MyModule::initialize</a>(<span class="keyword">const</span> datatools::properties&amp; myConfig,</div><div class="line">                          datatools::service_manager&amp; <span class="comment">/*flServices*/</span>,</div><div class="line">                          dpp::module_handle_dict_type&amp; <span class="comment">/*moduleDict*/</span>) {</div><div class="line">  <span class="comment">// Throw logic exception if we&#39;ve already initialized this instance</span></div><div class="line">  DT_THROW_IF(this-&gt;is_initialized(),</div><div class="line">              std::logic_error,</div><div class="line">              <span class="stringliteral">&quot;MyModule already initialized&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Extract the fudge_factor key from the supplied config, if</span></div><div class="line">  <span class="comment">// the key exists. datatools::properties throws an exception if</span></div><div class="line">  <span class="comment">// the key isn&#39;t in the config, so catch this if thrown and don&#39;t do</span></div><div class="line">  <span class="comment">// anything</span></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    myConfig.fetch(<span class="stringliteral">&quot;fudge_factor&quot;</span>,this-&gt;fudgeFactor_);</div><div class="line">  } <span class="keywordflow">catch</span> (std::logic_error&amp; e) {</div><div class="line">  }</div><div class="line"></div><div class="line">  this-&gt;_set_initialized(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Process</span></div><div class="line">dpp::base_module::process_status</div><div class="line">MyModule::process(datatools::things&amp; <span class="comment">/*workItem*/</span>) {</div><div class="line">  <span class="comment">// Hello world!</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;MyModule::process using fudgeFactor(&quot;</span></div><div class="line">            &lt;&lt; fudgeFactor_ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// MUST return a status, see ref dpp::processing_status_flags_type</span></div><div class="line">  <span class="keywordflow">return</span> PROCESS_OK;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Reset</span></div><div class="line"><span class="keywordtype">void</span> MyModule::reset() {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">false</span>);</div><div class="line">  fudgeFactor_ = 1.0;</div><div class="line">}</div></div><!-- fragment --><p>The key additions are:</p>
<ol type="1">
<li>Initializer for member in <code>MyModule</code> constructor.</li>
<li>Reset of member to default value in <code>reset</code> method.</li>
<li>Use of the <code>myConfig</code> datatools::properties instance passed to the <code>initialize</code> method to extract requested value for data member.</li>
</ol>
<p>The first two items are simply management tasks, and the third is where the main configuration is performed.</p>
<p>The use of the <code>DT_THROW_IF</code> macro is used to enforce one-time initialization of the module so that we can't accidently and silently override the configuration. This locking behaviour is not required, but is useful to prevent such accidental overwrites.</p>
<p>The try/catch block is used to "bind" the value of the <code>fudge_factor</code> string key from the <code>myConfig</code> <code>datatools::properties</code> instance to the actual <code>fudgeFactor_</code> data member. This is wrapped in a try/catch block because <code>datatools::properties</code> will throw a <code>std:logic_error</code> exception if</p>
<ol type="1">
<li>The key cannot be found.</li>
<li>The value of the key cannot be converted to the requested type (in this case <code>double</code>).</li>
</ol>
<p>We don't do anything if an exception is thrown here as we are happy in this case to use the default value for <code>fudgeFactor_</code> if the configuration does not override it or fails otherwise. Different error handling strategies can be applied to meet the needs of your own configurable parameters. You should consult the documentation for <code>datatools::properties</code> for full details of its key checking and extraction API.</p>
<p>An important restriction on configurable parameters is that they can only be of types understood by the <code>datatools::properties</code> class, namely:</p>
<ul>
<li><code>std::string</code></li>
<li><code>int</code></li>
<li><code>double</code></li>
<li><code>bool</code></li>
<li><code>std::vector</code> of all above types.</li>
</ul>
<h2>Building a Loadable Shared Library for a Configurable Module </h2>
<p>No special build setup is needed for a configurable module, so you can use the CMake script <a class="el" href="writingflreconstructmodules.html#minimalmodulebuilding">exactly as given for the basic module above</a>. If you've made the changes as above, simply rebuild!</p>
<h2><a class="anchor" id="minimalconfigurablemodulescript"></a>
Configuring MyModule from the Pipeline Script </h2>
<p>In the preceeding section, we saw that module configuration is passed to the module by an instance of the <code>datatools::properties</code> class. This instance is created by <code>flreconstruct</code> for the module from the properties, if any, supplied in the section of the pipeline script defining the module. To begin with, we can use the pipeline script from earlier to run the configurable module:</p>
<div class="fragment"><div class="line"># - Configuration Metadata</div><div class="line">#@description Chain pipeline using a single custom module</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line"># The &quot;flreconstruct.plugins&quot; section to tell flreconstruct what</div><div class="line"># to load and from where.</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line"># Make it use our custom module by setting the&#39;type&#39; key to the string we</div><div class="line"># used as the second argument to the macro</div><div class="line"># DPP_MODULE_REGISTRATION_IMPLEMENT in MyModule.cpp</div><div class="line"># At present, it takes no configuration, so it suffices to define it</div><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>and run it in <code>flreconstruct</code> with</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ cd /path/to/MyWorkSpace/MyModule-build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ ls</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;CMakeCache.txt  cmake_install.cmake  Makefile</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;CMakeFiles      libMyModule.so       MyModuleTest.brio</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModulePipeline.conf</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;[notice:void datatools::library_loader::init():410] Automatic loading of library  &#39;MyModule&#39;...</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Reader configuration parameters:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;|-- Name : &quot;files.mode&quot;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;|   |-- Type  : string (scalar)</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;|   `-- Value : &quot;single&quot;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;`-- Name : &quot;files.single.filename&quot;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    |-- Type  : string (scalar)</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    `-- Value : &quot;MyModuleTest.brio&quot;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;MyModule::process using fudgeFactor(1)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;$</div></div><!-- fragment --><p>We can see that the module has been run using the default value of the parameter. The section of the pipeline script defining <code>MyModule</code> is the line</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div></div><!-- fragment --><p>so to change the <code>fudgeFactor_</code> parameter, we simply add the appropriate <code>datatools::properties</code> key for it to the section:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;fudge_factor : real = 3.14;</div></div><!-- fragment --><p>where the key name <code>fudge_factor</code> must match that looked for in the <code>MyModule::initialize</code> method. How to document parameters is covered in <a class="el" href="documentingflreconstructmodules.html">a later tutorial</a>. The format of <code>datatools::properties</code> key entries is described in the documentation of that class.</p>
<p>Having add the key, we can rerun with the updated pipeline script:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModulePipeline.conf</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;[notice:void datatools::library_loader::init():410] Automatic loading of library  &#39;MyModule&#39;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;...</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Reader configuration parameters:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;|-- Name : &quot;files.mode&quot;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;|   |-- Type  : string (scalar)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;|   `-- Value : &quot;single&quot;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;`-- Name : &quot;files.single.filename&quot;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    |-- Type  : string (scalar)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    `-- Value : &quot;MyModuleTest.brio&quot;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;MyModule::process using fudgeFactor(3.14)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;$</div></div><!-- fragment --><p>and we see that the parameter has been changed to the value defined in the script. Try changing the value to see the effect.</p>
<p>Keys are bound to the section they are defined in, so we can use the same module type multiple times but with different parameters. For example, try the following pipeline script:</p>
<div class="fragment"><div class="line"># - Configuration</div><div class="line">#@description Simple pipeline using a chain</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Module load section</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line"></div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line">[name=&quot;pipeline&quot; type=&quot;dpp::chain_module&quot;]</div><div class="line">modules : string[3] = &quot;start_module&quot; &quot;dump&quot; &quot;end_module&quot;</div><div class="line"></div><div class="line">[name=&quot;start_module&quot; type=&quot;MyModule&quot;]</div><div class="line">fudge_factor : real = 3.14</div><div class="line"></div><div class="line">[name=&quot;dump&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line"></div><div class="line">[name=&quot;end_module&quot; type=&quot;MyModule&quot;]</div><div class="line">fudge_factor : real = 4.13</div><div class="line"></div></div><!-- fragment --><p>You should see each event being dumped, with the dumped info being bracketed by the output from each <code>MyModule</code> instance, each with different values of the fudge factor parameter.</p>
<p>Whilst this ability to make modules configurable is extremely useful, <em>you should aim to minimize the number of parameters your module takes</em>. This helps to make the module easier to use and less error prone. Remember that the modular structure of the pipeline means that tasks are broken down into smaller chunks, so you should consider refactoring complex modules into smaller orthogonal units.</p>
<h1>Next Steps </h1>
<p>The above examples have illustrated the basic structures needed to implement a module and load it into <code>flreconstruct</code>.</p>
<p>Practical modules will access the event object passed to them, process it and then write information back into the event record. <a class="el" href="workingwitheventrecords.html">Using the event data model in modules is covered in a dedicated tutorial</a>.</p>
<p>Modules may also need access to global data such as run conditions. FLReconstruct uses the concept of "Services" to provide such data, and <a class="el" href="usingservices.html">a tutorial on using services in modules is provided</a>.</p>
<p>Modules should also always be documented so that users have a clear picture of the task performed by the module and its configurable parameters. <a class="el" href="documentingflreconstructmodules.html">A tutorial on documenting modules using the builtin Falaise/Bayeux tools</a> is available.</p>
<p>Though modules for FLReconstruct may not be directly integrated in Falaise, for consistency and maintanability their code <a class="el" href="codingstandards.html">must follow the Falaise coding conventions</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
