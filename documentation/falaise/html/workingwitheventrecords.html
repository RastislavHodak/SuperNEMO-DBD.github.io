<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Falaise: Working With Events in FLReconstruct</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Falaise
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">SuperNEMO Software Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Working With Events in FLReconstruct </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#workingwitheventrecords_introduction">Introduction to event record </a></li>
<li class="level1"><a href="#workingwitheventrecords_things_readingdata">Reading Data from datatools::things Instances </a></li>
<li class="level1"><a href="#things_writingdata">Writing Data to datatools::things Instances </a></li>
<li class="level1"><a href="#things_customdata">Implementing Custom Objects for Storage in datatools::things </a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="workingwitheventrecords_introduction"></a>
Introduction to event record </h1>
<p>The C++ type used to represent events in <code>flreconstruct</code> is the datatools::things class. Pipeline module classes inherit from dpp::base_module and thus must implement the pure abstract method dpp::base_module::process . This method is called for each event, and is passed a reference to the mutable datatools::things object representing the current event being passed through the pipeline.</p>
<p>The <code>datatools::things</code> class implements an associative, hierarchical and heterogenous collection of objects. To put it in simpler terms, it provides a dictionary mapping string "keys" to object instances inheriting from the <code>datatools::i_serializable</code> pure abstract base class. It's the dictionary like interface that provides the associativity, and the storage of pointer-to-base-class that provides the heterogeneity (many different concrete types). As <code>datatools::things</code> itself inherits from <code>datatools::i_serializable</code>, it is capable of storing other <code>datatools::things</code> instances, providing the possibility of arranging objects in a tree-like structure.</p>
<p>In this tutorial, we'll look at three basic aspects of working with <code>datatools::things</code> instances provided to the <code>process</code> method of your custom pipeline module,</p>
<ol type="1">
<li>Reading data from the <code>datatools::things</code> instance</li>
<li>Writing builtin objects to the instance</li>
<li>Implementing custom objects for storage in <code>datatools::things</code></li>
</ol>
<h1><a class="anchor" id="workingwitheventrecords_things_readingdata"></a>
Reading Data from datatools::things Instances </h1>
<p>To work with events in the pipeline we first need to implement a pipeline module to do this. The basics of how to do this are covered in <a class="el" href="writingflreconstructmodules.html">a dedicated tutorial</a> and you should familiarize yourself with this material as this tutorial will build on it.</p>
<p>First of all we implement our module, build it and write a pipeline script to use it in <code>flreconstruct</code>. Note that we have stripped all comments except those relating to the process methods, and that the module takes no configuration. If you require details on how to implement a basic flreconstruct method, please refer to the <a class="el" href="writingflreconstructmodules.html">introductory tutorial</a> first. We begin with the header:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ACCESSTHINGSMODULE_HH</span></div><div class="line"><span class="preprocessor">#define ACCESSTHINGSMODULE_HH</span></div><div class="line"><span class="preprocessor">#include &quot;bayeux/dpp/base_module.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AccessThingsModule : <span class="keyword">public</span> dpp::base_module {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AccessThingsModule();</div><div class="line">  <span class="keyword">virtual</span> ~AccessThingsModule();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">initialize</a>(<span class="keyword">const</span> datatools::properties&amp; myConfig,</div><div class="line">                          datatools::service_manager&amp; flServices,</div><div class="line">                          dpp::module_handle_dict_type&amp; what);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> dpp::base_module::process_status process(datatools::things&amp; workItem);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  DPP_MODULE_REGISTRATION_INTERFACE(AccessThingsModule);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // ACCESSTHINGSMODULE_HH</span></div></div><!-- fragment --><p>and now the implementation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;AccessThingsModule.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;bayeux/mctools/simulated_data.h&quot;</span></div><div class="line"></div><div class="line">DPP_MODULE_REGISTRATION_IMPLEMENT(AccessThingsModule,<span class="stringliteral">&quot;AccessThingsModule&quot;</span>);</div><div class="line"></div><div class="line">AccessThingsModule::AccessThingsModule() : dpp::base_module()</div><div class="line">{}</div><div class="line"></div><div class="line">AccessThingsModule::~AccessThingsModule() {</div><div class="line">  <span class="keywordflow">if</span> (is_initialized()) this-&gt;reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">AccessThingsModule::initialize</a>(<span class="keyword">const</span> datatools::properties&amp; <span class="comment">/*myConfig*/</span>,</div><div class="line">                          datatools::service_manager&amp; <span class="comment">/*flServices*/</span>,</div><div class="line">                          dpp::module_handle_dict_type&amp; <span class="comment">/*moduleDict*/</span>) {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::Process]</span></div><div class="line"><span class="comment"></span>dpp::base_module::process_status</div><div class="line">AccessThingsModule::process(datatools::things&amp; workItem) {</div><div class="line">  <span class="comment">// Print most basic information</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;AccessThingsModule::process called!&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[name]        : &quot;</span> &lt;&lt; workItem.get_name() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[description] : &quot;</span> &lt;&lt; workItem.get_description() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Extract list of keys stored by the object</span></div><div class="line">  std::vector&lt;std::string&gt; workItemKeyList;</div><div class="line">  workItem.get_names(workItemKeyList);</div><div class="line"></div><div class="line">  <span class="comment">// Iterate over keys, printing their name and the type of the object</span></div><div class="line">  <span class="comment">// they map to</span></div><div class="line">  BOOST_FOREACH(std::string key, workItemKeyList) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;- [key, serial_tag] : &quot;</span></div><div class="line">              &lt;&lt; key</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">              &lt;&lt; workItem.get_entry_serial_tag(key)</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Grab simulated data bank</span></div><div class="line">  <span class="comment">// Simulated data will only be present in simulation output files,</span></div><div class="line">  <span class="comment">// so wrap in a try block</span></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keyword">const</span> mctools::simulated_data&amp; simData = workItem.get&lt;mctools::simulated_data&gt;(<span class="stringliteral">&quot;SD&quot;</span>);</div><div class="line">    simData.tree_dump();</div><div class="line">  } <span class="keywordflow">catch</span> (std::logic_error&amp; e) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;failed to grab SD bank : &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> dpp::base_module::PROCESS_INVALID;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// MUST return a status, see ref dpp::processing_status_flags_type</span></div><div class="line">  <span class="keywordflow">return</span> dpp::base_module::PROCESS_OK;</div><div class="line">}<span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::Process]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="keywordtype">void</span> AccessThingsModule::reset() {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p>The key method to look at is <code>AccessThings::process</code> which as we've seen before is passed a reference to the current event in the pipeline.</p>
<p>We begin working with the event by simply printing its name and description. This is a trivial demonstration that the <code>datatools::things</code> interface works, as for event date these are likely to be blank.</p>
<p>The second, more relevant task, is to extract the list of keys, and thus data banks, stored in the event. Here, we use the <code>datatools::things::get_names</code> method to fill a <code>std::vector</code> with the key names. We then iterate over this vector to print out the key name and, by using the <code>datatools::things::get_entry_serial_tag</code> method, typename of the object it maps to.</p>
<div class="fragment"><div class="line"><span class="comment">// Extract list of keys stored by the object</span></div><div class="line">std::vector&lt;std::string&gt; workItemKeyList;</div><div class="line">workItem.get_names(workItemKeyList);</div><div class="line"></div><div class="line"><span class="comment">// Iterate over keys, printing their name and the type of the object</span></div><div class="line"><span class="comment">// they map to</span></div><div class="line">BOOST_FOREACH(std::string key, workItemKeyList) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;- [key, serial_tag] : &quot;</span></div><div class="line">            &lt;&lt; key</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">            &lt;&lt; workItem.get_entry_serial_tag(key)</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>If we know the type of the key we wish to extract, we can use the <code>datatools::things::get</code> method to obtain a reference to it.</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div><div class="line">  <span class="keyword">const</span> mctools::simulated_data&amp; simData = workItem.get&lt;mctools::simulated_data&gt;(<span class="stringliteral">&quot;SD&quot;</span>);</div><div class="line">  simData.tree_dump();</div><div class="line">} <span class="keywordflow">catch</span> (std::logic_error&amp; e) {</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;failed to grab SD bank : &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> dpp::base_module::PROCESS_ERROR;</div><div class="line">}</div></div><!-- fragment --><p>We know that the "SD" ( <b>S</b> imulated <b>D</b> ata) entry should map to an instance of <code>mctools::simulated_data</code> so we use the <code>datatools::things::get</code> method to obtain a const reference to it (const being read only). This method takes a template argument which is the typename we want to extract, and a function argument which is the name of the key to get. The method will throw an exception if either</p>
<ul>
<li>The key does not exist.</li>
<li>The key exists, but it does not map to the requested type</li>
</ul>
<p>We therefore wrap the extraction in a try-catch block to handle both of these potential errors. If we're able to get the reference to the object, then we can use it directly. In this example, we simply use the <code>mctools::simulated_data::tree_dump</code> method to dump some information on the object to screen. You should consult the documentation of the classes extracted to see what you can do with them. If an exception is thrown, then we report the error to the standard error stream, and return the <code>dpp::base_module::PROCESS_INVALID</code> flag. This will make the pipeline abort any further processing of the event and subsequent events, but other flags are available to handle a range of process errors.</p>
<p>To see the effect of this reading, we compile the above code into a shared library just as before using the following CMake script:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># - Basic CMake setup</span></div><div class="line"><span class="preprocessor"># Check version meets ou requirements</span></div><div class="line"><span class="preprocessor"># Declare project, which will configure compiler for us</span></div><div class="line">cmake_minimum_required(VERSION 2.8)</div><div class="line">project(AccessThingsModule)</div><div class="line"></div><div class="line"><span class="preprocessor"># Modules use Bayeux, so we need to locate this or fail</span></div><div class="line">find_package(Bayeux REQUIRED)</div><div class="line"></div><div class="line"><span class="preprocessor"># Ensure our code can see the Bayeux headers</span></div><div class="line">include_directories(${Bayeux_INCLUDE_DIRS})</div><div class="line"></div><div class="line"># Build a dynamic library from our sources</div><div class="line">add_library(AccessThingsModule SHARED AccessThingsModule.h AccessThingsModule.cpp)</div><div class="line"></div><div class="line"><span class="preprocessor"># Apple linker requires dynamic lookup of symbols, so we</span></div><div class="line"><span class="preprocessor"># add link flags on this platform</span></div><div class="line"><span class="keywordflow">if</span>(APPLE)</div><div class="line">  set_target_properties(AccessThingsModule</div><div class="line">    PROPERTIES LINK_FLAGS <span class="stringliteral">&quot;-undefined dynamic_lookup&quot;</span></div><div class="line">    )</div><div class="line">endif()</div><div class="line"></div></div><!-- fragment --><p>and run <code>flreconstruct</code> with the following pipeline script:</p>
<p>To see the effect of this writing, we compile the above code into a shared library just as before using the following CMake script:</p>
<div class="fragment"><div class="line">#@description AccessThings Pipeline</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;AccessThingsModule&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line">[name=&quot;pipeline&quot; type=&quot;AccessThingsModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>You should see output similar to the dump modules we ran in earlier tutorials.</p>
<h1><a class="anchor" id="things_writingdata"></a>
Writing Data to datatools::things Instances </h1>
<p>As the <code>datatools::things</code> instance is passed to pipeline modules by non-const reference, it is directly modifiable by your module. This means your module can store results of working with the event back into the event for later modules to use (you can of course also delete existing data, so be careful!).</p>
<p>Instances of <code>datatools::things</code> can only store objects that inherit from the <code>datatools::i_serializable</code> abstract base class, so this restricts the types your module can add. For now we will just look at how to store an existing concrete class of <code>datatools::i_serializable</code> in <code>datatools::things</code>, specifically, the <code>datatools::properties</code> class. The use case of adding you own concrete classes of <code>datatools::i_serializable</code> is deferred to a <a class="el" href="workingwitheventrecords.html#things_customdata">later tutorial in this guide</a>.</p>
<p>We begin by refactoring the <code>process</code> method of our module into read and write parts, first the header</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ACCESSTHINGSMODULE_HH</span></div><div class="line"><span class="preprocessor">#define ACCESSTHINGSMODULE_HH</span></div><div class="line"><span class="preprocessor">#include &quot;bayeux/dpp/base_module.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AccessThingsModule : <span class="keyword">public</span> dpp::base_module {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AccessThingsModule();</div><div class="line">  <span class="keyword">virtual</span> ~AccessThingsModule();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">initialize</a>(<span class="keyword">const</span> datatools::properties&amp; myConfig,</div><div class="line">                          datatools::service_manager&amp; flServices,</div><div class="line">                          dpp::module_handle_dict_type&amp; what);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> dpp::base_module::process_status process(datatools::things&amp; workItem);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  dpp::base_module::process_status read(datatools::things&amp; workItem);</div><div class="line">  dpp::base_module::process_status write(datatools::things&amp; workItem);</div><div class="line"></div><div class="line">  DPP_MODULE_REGISTRATION_INTERFACE(AccessThingsModule);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // ACCESSTHINGSMODULE_HH</span></div><div class="line"></div></div><!-- fragment --><p>and then the implementation</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;AccessThingsModule.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;bayeux/mctools/simulated_data.h&quot;</span></div><div class="line"></div><div class="line">DPP_MODULE_REGISTRATION_IMPLEMENT(AccessThingsModule,<span class="stringliteral">&quot;AccessThingsModule&quot;</span>);</div><div class="line"></div><div class="line">AccessThingsModule::AccessThingsModule() : dpp::base_module()</div><div class="line">{}</div><div class="line"></div><div class="line">AccessThingsModule::~AccessThingsModule() {</div><div class="line">  this-&gt;reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">AccessThingsModule::initialize</a>(<span class="keyword">const</span> datatools::properties&amp; <span class="comment">/*myConfig*/</span>,</div><div class="line">                          datatools::service_manager&amp; <span class="comment">/*flServices*/</span>,</div><div class="line">                          dpp::module_handle_dict_type&amp; <span class="comment">/*moduleDict*/</span>) {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::Process]</span></div><div class="line"><span class="comment"></span>dpp::base_module::process_status AccessThingsModule::process(</div><div class="line">    datatools::things&amp; workItem) {</div><div class="line">  process_status readStatus = this-&gt;read(workItem);</div><div class="line">  <span class="keywordflow">if</span> (readStatus != PROCESS_OK) <span class="keywordflow">return</span> readStatus;</div><div class="line"></div><div class="line">  process_status writeStatus = this-&gt;write(workItem);</div><div class="line"></div><div class="line">  <span class="comment">// MUST return a status, see ref dpp::processing_status_flags_type</span></div><div class="line">  <span class="keywordflow">return</span> writeStatus;</div><div class="line">}<span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::Process]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="keywordtype">void</span> AccessThingsModule::reset() {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line">dpp::base_module::process_status AccessThingsModule::read(datatools::things&amp; workItem) {</div><div class="line">  <span class="comment">// Print most basic information</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;AccessThingsModule::process called!&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[name]        : &quot;</span> &lt;&lt; workItem.get_name() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[description] : &quot;</span> &lt;&lt; workItem.get_description() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Extract list of keys stored by the object</span></div><div class="line">  std::vector&lt;std::string&gt; workItemKeyList;</div><div class="line">  workItem.get_names(workItemKeyList);</div><div class="line"></div><div class="line">  <span class="comment">// Iterate over keys, printing their name and the type of the object</span></div><div class="line">  <span class="comment">// they map to</span></div><div class="line">  BOOST_FOREACH(std::string key, workItemKeyList) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;- [key, serial_tag] : &quot;</span></div><div class="line">              &lt;&lt; key</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">              &lt;&lt; workItem.get_entry_serial_tag(key)</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Grab simulated data bank</span></div><div class="line">  <span class="comment">// Simulated data will only be present in simulation output files,</span></div><div class="line">  <span class="comment">// so wrap in a try block</span></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keyword">const</span> mctools::simulated_data&amp; simData = workItem.get&lt;mctools::simulated_data&gt;(<span class="stringliteral">&quot;SD&quot;</span>);</div><div class="line">    simData.tree_dump();</div><div class="line">  } <span class="keywordflow">catch</span> (std::logic_error&amp; e) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;failed to grab SD bank : &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> PROCESS_INVALID;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> PROCESS_OK;</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::write]</span></div><div class="line"><span class="comment"></span>dpp::base_module::process_status AccessThingsModule::write(datatools::things&amp; workItem) {</div><div class="line">  <span class="comment">// Add a new entry to the things</span></div><div class="line">  datatools::properties&amp; atmProperties = workItem.add&lt;datatools::properties&gt;(<span class="stringliteral">&quot;ATMProperties&quot;</span>);</div><div class="line">  atmProperties.set_description(<span class="stringliteral">&quot;Properties added by the AccessThings Module&quot;</span>);</div><div class="line">  atmProperties.store(<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>);</div><div class="line">  atmProperties.store(<span class="stringliteral">&quot;baz&quot;</span>, 3.14);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> PROCESS_OK;</div><div class="line">}</div></div><!-- fragment --><p>This separation is done for clarity in this example, but it illustrates that your <code>process</code> method need not be monolithic (and in fact shouldn't be except for trivial cases). The <code>read</code> method is exactly as we implemented earlier. In the <code>write</code> method, we use the <code>datatools::things::add</code> method to add new data bank to the event holding a <code>datatools::properties</code> instance. We pass this method a template argument indicating the type of the data bank, and a string function argument indicating the key under which to store the new data bank. The method returns a reference to the newly created instance so it can be modified in place, as we do by setting the description and adding two properties.</p>
<p>To see the effect of this writing, we compile the above code into a shared library just as before using the following CMake script:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># - Basic CMake setup</span></div><div class="line"><span class="preprocessor"># Check version meets ou requirements</span></div><div class="line"><span class="preprocessor"># Declare project, which will configure compiler for us</span></div><div class="line">cmake_minimum_required(VERSION 2.8)</div><div class="line">project(AccessThingsModule)</div><div class="line"></div><div class="line"><span class="preprocessor"># Modules use Bayeux, so we need to locate this or fail</span></div><div class="line">find_package(Bayeux REQUIRED)</div><div class="line"></div><div class="line"><span class="preprocessor"># Ensure our code can see the Bayeux headers</span></div><div class="line">include_directories(${Bayeux_INCLUDE_DIRS})</div><div class="line"></div><div class="line"># Build a dynamic library from our sources</div><div class="line">add_library(AccessThingsModule SHARED AccessThingsModule.h AccessThingsModule.cpp)</div><div class="line"></div><div class="line"><span class="preprocessor"># Apple linker requires dynamic lookup of symbols, so we</span></div><div class="line"><span class="preprocessor"># add link flags on this platform</span></div><div class="line"><span class="keywordflow">if</span>(APPLE)</div><div class="line">  set_target_properties(AccessThingsModule</div><div class="line">    PROPERTIES LINK_FLAGS <span class="stringliteral">&quot;-undefined dynamic_lookup&quot;</span></div><div class="line">    )</div><div class="line">endif()</div><div class="line"></div></div><!-- fragment --><p>To see the effect of the writing new banks into the event, we use a pipeline script to sandwich the module between two dump modules as follows</p>
<div class="fragment"><div class="line">#@description AccessThings Pipeline</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;AccessThingsModule&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line">[name=&quot;pipeline&quot; type=&quot;dpp::chain_module&quot;]</div><div class="line">modules : string[3] = &quot;preprocess&quot; &quot;access_things&quot; &quot;postprocess&quot;</div><div class="line"></div><div class="line">[name=&quot;preprocess&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line">title : string = &quot;PreProcess&quot;</div><div class="line"></div><div class="line">[name=&quot;postprocess&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line">title : string = &quot;PostProcess&quot;</div><div class="line"></div><div class="line">[name=&quot;access_things&quot; type=&quot;AccessThingsModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>You should see that the <code>PostProcess</code> stage results in output containing the information written into the <code>ATMProperties</code> bank.</p>
<h1><a class="anchor" id="things_customdata"></a>
Implementing Custom Objects for Storage in datatools::things </h1>
<p>As discussed above, the <code>datatools::things</code> object can store instances of any type inheriting from <code>datatools::i_serializable</code>. If the builtin types provided by Falaise and Bayeux do not meet your needs, you can implement a new custom class derived from <code>datatools::i_serializable</code>.</p>
<p>In this example, we will implement a simple custom class and add it into the <code>datatools::things</code> event record. This class <b>must</b> inherit from the pure abstract base class <code>datatools::i_serializable</code> and hence <b>must</b>:</p>
<ul>
<li>Provide a <code>public</code> default constructor</li>
<li>Provide a <code>public</code> virtual destructor</li>
<li>Concretely implement the <code>datatools::i_serializable::get_serial_tag()</code> pure virtual method</li>
</ul>
<p>In addition, to make the type usable by the serialization system, we need to use a couple of macros to declare and define the serialization mechanisms for us.</p>
<p>We therefore begin by writing the header file, which we'll name <code>MyDataType.h</code>:</p>
<div class="fragment"><div class="line"><span class="comment">//! \file    MyDataType.h</span></div><div class="line"><span class="comment"></span><span class="comment">//! \brief   Example custom data type for use with datatools::things</span></div><div class="line"><span class="comment"></span><span class="comment">//! \details Store an integer for later use</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="preprocessor">#ifndef MYDATATYPE_HH</span></div><div class="line"><span class="preprocessor">#define MYDATATYPE_HH</span></div><div class="line"><span class="comment">// Standard Library</span></div><div class="line"></div><div class="line"><span class="comment">// Third Party</span></div><div class="line"><span class="comment">// - Bayeux</span></div><div class="line"><span class="preprocessor">#include &quot;bayeux/datatools/i_serializable.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// This Project</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyDataType : <span class="keyword">public</span> datatools::i_serializable {</div><div class="line"> <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //! Construct type</span></div><div class="line"><span class="comment"></span>  MyDataType();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Destructor</span></div><div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> ~MyDataType();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Increment counter</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> increment();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Return value of counter</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">int</span> current_value() <span class="keyword">const</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Declare serialization interfaces for tagging and streaming</span></div><div class="line"><span class="comment"></span>  DATATOOLS_SERIALIZATION_DECLARATION()</div><div class="line"></div><div class="line"> private:</div><div class="line">  <span class="keywordtype">int</span> mdtCounter_;  <span class="comment">//!&lt; Stored counter</span></div><div class="line"><span class="comment"></span>};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // MYDATATYPE_HH</span></div><div class="line"></div></div><!-- fragment --><p>Note the inheritance from <code>datatools::i_serializable</code> and the use of the <code>DATATOOLS_SERIALIZATION_DECLARATION</code> macro, which declares the tagging/serialization methods for us. We have also provide concrete methods to implement this type as a simple increment-only counter. Note also the use of Doxygen markup to document the file and methods. You don't need to do this, but it is very useful and helps if your data type is to be integrated into the official mainline pipeline.</p>
<p>With the header in place we not add the implementation file, which we'll name <code>MyDataType.cpp</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MyDataType.h&quot;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! Implement the serialization tag mechanism</span></div><div class="line"><span class="comment"></span>DATATOOLS_SERIALIZATION_SERIAL_TAG_IMPLEMENTATION(MyDataType,<span class="stringliteral">&quot;MyDataType&quot;</span>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! Constructor</span></div><div class="line"><span class="comment"></span>MyDataType::MyDataType() : <a class="code" href="namespacedatatools.html">datatools</a>::i_serializable(), mdtCounter_(0) {</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! Destructor</span></div><div class="line"><span class="comment"></span>MyDataType::~MyDataType() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyDataType::increment() {</div><div class="line">  ++mdtCounter_;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> MyDataType::current_value()<span class="keyword"> const </span>{</div><div class="line">  <span class="keywordflow">return</span> mdtCounter_;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Here we've implemented the trivial constructor/destructor and the counter implementation, and added the <code>DATATOOLS_SERIALIZATION_SERIAL_TAG_IMPLEMENTATION</code> macro. This, together with the use of <code>DATATOOLS_SERIALIZATION_DECLARATION</code> in the header file provides the <b>minimal</b> boilerplate allowing the class to be stored in <code>datatools::things</code>. Further work is needed to make the type fully serializable, but we defer this to a later tutorial.</p>
<p>To use this type in the pipeline, we update the implementation of the <code>AccessThings</code> module as follows for the header:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ACCESSTHINGSMODULE_HH</span></div><div class="line"><span class="preprocessor">#define ACCESSTHINGSMODULE_HH</span></div><div class="line"><span class="preprocessor">#include &quot;bayeux/dpp/base_module.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AccessThingsModule : <span class="keyword">public</span> dpp::base_module {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AccessThingsModule();</div><div class="line">  <span class="keyword">virtual</span> ~AccessThingsModule();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">initialize</a>(<span class="keyword">const</span> datatools::properties&amp; myConfig,</div><div class="line">                          datatools::service_manager&amp; flServices,</div><div class="line">                          dpp::module_handle_dict_type&amp; what);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> dpp::base_module::process_status process(</div><div class="line">      datatools::things&amp; workItem);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  DPP_MODULE_REGISTRATION_INTERFACE(AccessThingsModule);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // ACCESSTHINGSMODULE_HH</span></div><div class="line"></div></div><!-- fragment --><p>and the implementation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;AccessThingsModule.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;bayeux/mctools/simulated_data.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;MyDataType.h&quot;</span></div><div class="line"></div><div class="line">DPP_MODULE_REGISTRATION_IMPLEMENT(AccessThingsModule,<span class="stringliteral">&quot;AccessThingsModule&quot;</span>);</div><div class="line"></div><div class="line">AccessThingsModule::AccessThingsModule() : dpp::base_module()</div><div class="line">{}</div><div class="line"></div><div class="line">AccessThingsModule::~AccessThingsModule() {</div><div class="line">  this-&gt;reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacefalaise.html#a4ff70f3eee21cfce309e3b859509c0e6">AccessThingsModule::initialize</a>(<span class="keyword">const</span> datatools::properties&amp; <span class="comment">/*myConfig*/</span>,</div><div class="line">                          datatools::service_manager&amp; <span class="comment">/*flServices*/</span>,</div><div class="line">                          dpp::module_handle_dict_type&amp; <span class="comment">/*moduleDict*/</span>) {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::Process]</span></div><div class="line"><span class="comment"></span>dpp::base_module::process_status AccessThingsModule::process(</div><div class="line">    datatools::things&amp; workItem) {</div><div class="line">  <span class="comment">// Add our custom type to the item</span></div><div class="line">  MyDataType &amp; atmCounter = workItem.add&lt;MyDataType&gt;(<span class="stringliteral">&quot;ATMCounter&quot;</span>);</div><div class="line">  atmCounter.increment();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> PROCESS_OK;</div><div class="line"></div><div class="line">}<span class="comment"></span></div><div class="line"><span class="comment">//! [AccessThingsModule::Process]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="keywordtype">void</span> AccessThingsModule::reset() {</div><div class="line">  this-&gt;_set_initialized(<span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p>Note the inclusion of the <code>MyDataType</code> header. We use the <code>datatools::things::add</code> method to add a <code>MyDataType</code> bank to the event. To compile the new type into a loadable module, we simply add the header and implementation to the <code>add_library</code> call in the <code>CMakeLists.txt</code> script:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># - Basic CMake setup</span></div><div class="line"><span class="preprocessor"># Check version meets ou requirements</span></div><div class="line"><span class="preprocessor"># Declare project, which will configure compiler for us</span></div><div class="line">cmake_minimum_required(VERSION 2.8)</div><div class="line">project(AccessThingsModuleCustom)</div><div class="line"></div><div class="line"><span class="preprocessor"># Modules use Bayeux, so we need to locate this or fail</span></div><div class="line">find_package(Bayeux REQUIRED)</div><div class="line"></div><div class="line"><span class="preprocessor"># Ensure our code can see the Bayeux headers</span></div><div class="line">include_directories(${Bayeux_INCLUDE_DIRS})</div><div class="line"></div><div class="line"># Build a dynamic library from our sources</div><div class="line">add_library(AccessThingsModule SHARED</div><div class="line">  AccessThingsModule.h</div><div class="line">  AccessThingsModule.cpp</div><div class="line">  MyDataType.h</div><div class="line">  MyDataType.cpp</div><div class="line">  )</div><div class="line"></div><div class="line"><span class="preprocessor"># Apple linker requires dynamic lookup of symbols, so we</span></div><div class="line"><span class="preprocessor"># add link flags on this platform</span></div><div class="line"><span class="keywordflow">if</span>(APPLE)</div><div class="line">  set_target_properties(AccessThingsModule</div><div class="line">    PROPERTIES LINK_FLAGS <span class="stringliteral">&quot;-undefined dynamic_lookup&quot;</span></div><div class="line">    )</div><div class="line">endif()</div><div class="line"></div></div><!-- fragment --><p>To see the effect of writing our own type, we compile the above code into a shared library using the above CMake script and then use the following pipeline script to sandwich the module between two dump modules</p>
<div class="fragment"><div class="line">#@description AccessThings Pipeline</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;&quot;]</div><div class="line">plugins : string[1] = &quot;AccessThingsModule&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line">[name=&quot;pipeline&quot; type=&quot;dpp::chain_module&quot;]</div><div class="line">modules : string[3] = &quot;preprocess&quot; &quot;access_things&quot; &quot;postprocess&quot;</div><div class="line"></div><div class="line">[name=&quot;preprocess&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line">title : string = &quot;PreProcess&quot;</div><div class="line"></div><div class="line">[name=&quot;postprocess&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line">title : string = &quot;PostProcess&quot;</div><div class="line"></div><div class="line">[name=&quot;access_things&quot; type=&quot;AccessThingsModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>You should see that the <code>PostProcess</code> stage results in output containing the information written into the <code>ATMCounter</code> bank. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
